// Copyright 2025 Holochip, Inc.
// SPDX-License-Identifier: CC-BY-4.0

ifndef::chapters[:chapters:]
ifndef::images[:images: images/]

[[shader-authoring-guide-slang-hlsl]]
= Shader Authoring Guide (Slang/HLSL)
:toc:

This chapter provides a comprehensive guide for writing shaders in Slang and HLSL for Vulkan applications. It covers best practices, migration from GLSL, Vulkan-specific semantics, bindings, entry points, and compiling to SPIR-V.

== Introduction to Slang and HLSL in Vulkan

While Vulkan consumes shaders in xref:{chapters}what_is_spirv.adoc[SPIR-V] format, developers can author shaders in high-level languages like HLSL (High-Level Shading Language) and Slang. This chapter builds upon the xref:{chapters}hlsl.adoc[HLSL in Vulkan] chapter, focusing specifically on authoring shaders for Vulkan applications.

=== What is Slang?

link:https://github.com/shader-slang/slang[Slang] is a modern shading
language and compiler designed to extend HLSL with advanced features. It's
largely backward-compatible with HLSL 2018 but adds features like generics,
interfaces, and reflection capabilities. Slang can target multiple backends, including SPIR-V for Vulkan.

Key features of Slang include:

* Largely compatible with HLSL syntax
* Advanced language features like generics, interfaces, and modules
* Cross-compilation to multiple targets, including SPIR-V for Vulkan
* Powerful metaprogramming capabilities
* Built-in shader reflection

=== Why Use HLSL or Slang for Vulkan?

There are several advantages to using HLSL or Slang for Vulkan development:

* *Cross-API compatibility*: Write shaders that can be used with both Vulkan and DirectX with minimal changes
* *Familiar syntax*: Developers with DirectX experience can leverage their existing knowledge
* *Advanced language features*: Particularly with Slang, access to modern programming constructs
* *Industry adoption*: HLSL is widely used in game engines and graphics applications
* *Tooling support*: Rich ecosystem of tools, debuggers, and IDE integrations

== Differences Between HLSL and Slang

While Slang is built on HLSL and maintains backward compatibility, it adds several powerful features that make shader development more efficient, maintainable, and flexible.

=== Language Feature Differences

==== Generics and Templates

Slang adds full support for generics, similar to C# or Java, allowing for type-safe parameterized code:

[source,slang]
----
// Generic function in Slang
template<T>
T min(T a, T b) {
    return a < b ? a : b;
}

// Usage
float result = min<float>(1.0, 2.0);
int intResult = min<int>(5, 3);
----

HLSL has limited template support, but Slang's generics are more robust and flexible than HLSL's templates.

==== Interfaces and Polymorphism

Slang introduces interfaces, enabling polymorphic behavior in shaders:

[source,slang]
----
// Define an interface
interface IMaterial {
    float3 evaluateBRDF(float3 viewDir, float3 lightDir, float3 normal);
}

// Implement the interface
struct LambertianMaterial : IMaterial {
    float3 albedo;

    float3 evaluateBRDF(float3 viewDir, float3 lightDir, float3 normal) {
        return albedo / 3.14159;
    }
}

// Use polymorphically
void shadeSurface(IMaterial material, ...) {
    // Use the material interface without knowing the concrete type
}
----

This feature is not available in standard HLSL.

==== Modules and Namespaces

Slang provides a module system for better code organization:

[source,slang]
----
// In file: lighting.slang
module Lighting;

export float3 calculateDirectLighting(...) { ... }
export float3 calculateIndirectLighting(...) { ... }

// In another file
import Lighting;

float3 color = Lighting.calculateDirectLighting(...);
----

HLSL lacks a formal module system, relying instead on file includes.

==== Advanced Metaprogramming

Slang offers powerful compile-time metaprogramming capabilities:

[source,slang]
----
// Compile-time reflection
struct Material {
    float4 baseColor;
    float roughness;
    float metallic;
};

// Get all fields of a type at compile time
__generic<T>
void bindMaterial(ParameterBlock<T> block, Material material) {
    __for(field in getFields(T)) {
        block.setField(field.name, getField(material, field.name));
    }
}
----

==== Resource Binding Model

Slang introduces a more flexible resource binding model:

[source,slang]
----
// Parameter block concept
ParameterBlock<LightingParams> lightingParams;

// Accessing resources
Texture2D albedoMap = lightingParams.albedoMap;
----

This provides better organization and more flexible binding than HLSL's register-based approach.

=== Syntax Differences

While Slang largely maintains HLSL syntax compatibility, it introduces some
new syntax elements:

* *Module declarations*: `module ModuleName;`
* *Import statements*: `import ModuleName;`
* *Interface declarations*: `interface IName { ... }`
* *Generic type parameters*: `<T>` or `__generic<T>`
* *Export keyword*: `export` to make symbols visible outside a module
* *Extended attributes*: Additional attributes for reflection and code generation

=== Compilation Differences

Slang provides its own compiler (`slangc`) with different capabilities than the HLSL compiler:

* *Multi-target compilation*: Compile the same shader for multiple graphics APIs
* *Cross-compilation*: Generate code for different shader stages from a single source
* *Built-in reflection*: Generate reflection data during compilation
* *Shader linking*: Link multiple shader modules together
* *Diagnostic quality*: More detailed error messages and warnings

Example of multi-target compilation:

[source,bash]
----
slangc -profile glsl_spirv -entry main -stage vertex shader.slang -o shader.vert.spv
slangc -profile dxbc -entry main -stage vertex shader.slang -o shader.vert.dxbc
----

=== Runtime Behavior Differences

Slang introduces some runtime behavior differences:

* *Dynamic dispatch*: Support for interface-based polymorphism
* *Resource binding*: More flexible resource binding model
* *Parameter blocks*: Hierarchical organization of shader parameters
* *Reflection API*: Runtime access to shader structure information

== Migration Guide: Transitioning from HLSL to Slang

Migrating from HLSL to Slang can be done incrementally, as Slang maintains backward compatibility with HLSL. This guide provides a step-by-step approach to transitioning your shaders.

=== Step 1: Setting Up the Slang Compiler

1. Download and install the Slang compiler from the https://github.com/shader-slang/slang[official repository]
2. Update your build scripts to use `slangc` instead of `dxc` or other HLSL compilers
3. Test compilation of existing HLSL shaders without modifications

Example build script update:

[source,bash]
----
# Before: Using DXC
dxc -spirv -T vs_6_0 -E main shader.hlsl -Fo shader.vert.spv

# After: Using Slang
slangc -profile glsl_spirv -entry main -stage vertex shader.hlsl -o shader.vert.spv
----

=== Step 2: Rename Files and Add Module Declarations

1. Rename your `.hlsl` files to `.slang` to indicate the language change
2. Add module declarations at the top of each file
3. Add export keywords to functions and types that need to be visible outside the module

Example transformation:

Before (shader.hlsl):
[source,hlsl]
----
struct VSInput {
    float3 position : POSITION;
    float3 normal : NORMAL;
};

float4 transformPosition(float3 position) {
    return mul(worldViewProj, float4(position, 1.0));
}
----

After (shader.slang):
[source,slang]
----
module Shaders.Transform;

export struct VSInput {
    float3 position : POSITION;
    float3 normal : NORMAL;
};

export float4 transformPosition(float3 position) {
    return mul(worldViewProj, float4(position, 1.0));
}
----

=== Step 3: Leverage Imports Instead of Includes

Replace `#include` directives with Slang's import system:

Before (HLSL):
[source,hlsl]
----
#include "common.hlsl"
#include "lighting.hlsl"

float3 calculateLighting(...) {
    // Use functions from included files
}
----

After (Slang):
[source,slang]
----
module Shaders.Fragment;

import Shaders.Common;
import Shaders.Lighting;

export float3 calculateLighting(...) {
    // Use functions from imported modules
}
----

=== Step 4: Refactor Resource Bindings

Update resource bindings to use Slang's parameter block system:

Before (HLSL):
[source,hlsl]
----
Texture2D albedoMap : register(t0);
SamplerState samplerState : register(s0);
cbuffer MaterialParams : register(b0) {
    float4 baseColor;
    float roughness;
    float metallic;
};
----

After (Slang):
[source,slang]
----
struct MaterialResources {
    Texture2D albedoMap;
    SamplerState samplerState;
    struct Params {
        float4 baseColor;
        float roughness;
        float metallic;
    } constants;
};

ParameterBlock<MaterialResources> material;

// Usage
float4 albedo = material.albedoMap.Sample(material.samplerState, uv);
float roughness = material.constants.roughness;
----

=== Step 5: Introduce Generics and Interfaces

Identify opportunities to use generics and interfaces for more flexible code:

Before (HLSL):
[source,hlsl]
----
float3 evaluateLambert(float3 albedo, float3 normal, float3 lightDir) {
    return albedo * max(0, dot(normal, lightDir)) / 3.14159;
}

float3 evaluateGGX(float3 specColor, float roughness, float3 normal, float3 viewDir, float3 lightDir) {
    // GGX implementation
}

float3 evaluateMaterial(MaterialType type, ...) {
    switch(type) {
        case MATERIAL_LAMBERT: return evaluateLambert(...);
        case MATERIAL_GGX: return evaluateGGX(...);
        default: return float3(0,0,0);
    }
}
----

After (Slang):
[source,slang]
----
interface IBRDF {
    float3 evaluate(float3 normal, float3 viewDir, float3 lightDir);
}

struct LambertBRDF : IBRDF {
    float3 albedo;

    float3 evaluate(float3 normal, float3 viewDir, float3 lightDir) {
        return albedo * max(0, dot(normal, lightDir)) / 3.14159;
    }
}

struct GGXBRDF : IBRDF {
    float3 specColor;
    float roughness;

    float3 evaluate(float3 normal, float3 viewDir, float3 lightDir) {
        // GGX implementation
    }
}

float3 evaluateMaterial(IBRDF brdf, float3 normal, float3 viewDir, float3 lightDir) {
    return brdf.evaluate(normal, viewDir, lightDir);
}
----

=== Step 6: Implement Advanced Metaprogramming

Use Slang's metaprogramming capabilities for more powerful shader generation:

[source,slang]
----
// Define shader permutations using compile-time parameters
[shader("vertex")]
[CompileTimeConstant(name="USE_NORMAL_MAPPING", type="bool")]
[CompileTimeConstant(name="LIGHT_COUNT", type="int")]
VSOutput vertexShader(VSInput input) {
    VSOutput output;
    // Base implementation

    #if USE_NORMAL_MAPPING
    // Normal mapping specific code
    #endif

    for (int i = 0; i < LIGHT_COUNT; i++) {
        // Per-light calculations
    }

    return output;
}
----

=== Common Migration Challenges

==== Resource Binding Compatibility

**Challenge**: Slang's resource binding model differs from HLSL's register-based approach.

**Solution**:

- Use Slang's `register` compatibility syntax during transition
- Gradually migrate to parameter blocks
- Update shader binding code in your application

==== Module Organization

**Challenge**: Deciding how to organize code into modules.

**Solution**:

- Group related functionality into modules
- Use hierarchical naming (e.g., `Rendering.Lighting`)
- Start with coarse-grained modules and refine as needed

==== Interface Performance

**Challenge**: Concerns about runtime performance of interfaces.

**Solution**:

- Interfaces are often resolved at compile-time
- Use interfaces for flexibility in high-level code
- Profile performance-critical paths

==== Compilation Pipeline Integration

**Challenge**: Integrating Slang into existing build systems.

**Solution**:

- Create wrapper scripts to maintain command-line compatibility
- Update build tools to support both HLSL and Slang during transition
- Consider using Slang's API for deeper integration

=== Best Practices for Migration

1. **Incremental Approach**: Migrate one shader or shader module at a time
2. **Maintain Compatibility**: Use Slang's HLSL compatibility features during transition
3. **Test Thoroughly**: Verify visual output after each migration step
4. **Refactor Gradually**: Start with simple syntax changes, then introduce advanced features
5. **Leverage Modules**: Use the module system to improve code organization
6. **Document Changes**: Keep track of migration decisions and patterns
7. **Performance Profiling**: Monitor performance before and after migration

=== Example: Complete HLSL to Slang Migration

Below is a complete example of migrating a simple shader from HLSL to Slang:

HLSL Version (pbr.hlsl):
[source,hlsl]
----
// PBR shader in HLSL
#include "common.hlsl"

struct VSInput {
    float3 position : POSITION;
    float3 normal : NORMAL;
    float2 texCoord : TEXCOORD0;
};

struct PSInput {
    float4 position : SV_POSITION;
    float3 worldPos : POSITION;
    float3 normal : NORMAL;
    float2 texCoord : TEXCOORD0;
};

Texture2D albedoMap : register(t0);
Texture2D normalMap : register(t1);
Texture2D metallicRoughnessMap : register(t2);
SamplerState textureSampler : register(s0);

cbuffer MaterialParams : register(b0) {
    float4 baseColor;
    float metallic;
    float roughness;
    float2 padding;
};

cbuffer SceneParams : register(b1) {
    float4x4 viewProj;
    float4x4 world;
    float3 cameraPosition;
    float padding2;
};

PSInput VSMain(VSInput input) {
    PSInput output;
    float4 worldPos = mul(world, float4(input.position, 1.0));
    output.position = mul(viewProj, worldPos);
    output.worldPos = worldPos.xyz;
    output.normal = normalize(mul((float3x3)world, input.normal));
    output.texCoord = input.texCoord;
    return output;
}

float4 PSMain(PSInput input) : SV_TARGET {
    float4 albedo = albedoMap.Sample(textureSampler, input.texCoord) * baseColor;
    float2 metallicRoughness = metallicRoughnessMap.Sample(textureSampler, input.texCoord).rg;
    float metalness = metallicRoughness.r * metallic;
    float roughnessValue = metallicRoughness.g * roughness;

    float3 normal = normalize(input.normal);
    float3 viewDir = normalize(cameraPosition - input.worldPos);

    // PBR calculation
    float3 color = calculatePBRLighting(albedo.rgb, metalness, roughnessValue, normal, viewDir);

    return float4(color, albedo.a);
}

float3 calculatePBRLighting(float3 albedo, float metalness, float roughness, float3 normal, float3 viewDir) {
    // Simplified PBR calculation
    float3 lightDir = normalize(float3(1, 1, 1));
    float3 halfVector = normalize(viewDir + lightDir);

    float NdotL = max(dot(normal, lightDir), 0.0);
    float NdotV = max(dot(normal, viewDir), 0.0);
    float NdotH = max(dot(normal, halfVector), 0.0);
    float VdotH = max(dot(viewDir, halfVector), 0.0);

    float3 F0 = lerp(float3(0.04, 0.04, 0.04), albedo, metalness);

    // Simplified lighting equation
    float3 diffuse = (1.0 - metalness) * albedo / 3.14159;
    float3 specular = calculateSpecular(F0, roughness, NdotH, NdotV, NdotL, VdotH);

    return (diffuse + specular) * NdotL * float3(1, 1, 1); // Light color = white
}

float3 calculateSpecular(float3 F0, float roughness, float NdotH, float NdotV, float NdotL, float VdotH) {
    // Simplified specular calculation
    float alpha = roughness * roughness;
    float D = alpha * alpha / (3.14159 * pow(NdotH * NdotH * (alpha * alpha - 1.0) + 1.0, 2.0));
    float G = NdotV * NdotL;
    float3 F = F0 + (float3(1, 1, 1) - F0) * pow(1.0 - VdotH, 5.0);

    return D * G * F / max(0.0001, 4.0 * NdotV * NdotL);
}
----

Slang Version (pbr.slang):
[source,slang]
----
// PBR shader in Slang
module Rendering.PBR;

import Rendering.Common;

// Input/output structures
export struct VSInput {
    float3 position : POSITION;
    float3 normal : NORMAL;
    float2 texCoord : TEXCOORD0;
};

export struct PSInput {
    float4 position : SV_POSITION;
    float3 worldPos : POSITION;
    float3 normal : NORMAL;
    float2 texCoord : TEXCOORD0;
};

// Resource definitions using parameter blocks
struct MaterialResources {
    Texture2D albedoMap;
    Texture2D normalMap;
    Texture2D metallicRoughnessMap;
    SamplerState textureSampler;

    struct Constants {
        float4 baseColor;
        float metallic;
        float roughness;
        float2 padding;
    } params;
};

struct SceneResources {
    struct Constants {
        float4x4 viewProj;
        float4x4 world;
        float3 cameraPosition;
        float padding;
    } params;
};

// Parameter blocks
ParameterBlock<MaterialResources> material;
ParameterBlock<SceneResources> scene;

// BRDF interface for different lighting models
interface IBRDF {
    float3 evaluate(float3 albedo, float3 normal, float3 viewDir, float3 lightDir);
}

// PBR BRDF implementation
struct PBRBRDF : IBRDF {
    float metalness;
    float roughness;

    float3 evaluate(float3 albedo, float3 normal, float3 viewDir, float3 lightDir) {
        float3 halfVector = normalize(viewDir + lightDir);

        float NdotL = max(dot(normal, lightDir), 0.0);
        float NdotV = max(dot(normal, viewDir), 0.0);
        float NdotH = max(dot(normal, halfVector), 0.0);
        float VdotH = max(dot(viewDir, halfVector), 0.0);

        float3 F0 = lerp(float3(0.04, 0.04, 0.04), albedo, metalness);

        // Simplified lighting equation
        float3 diffuse = (1.0 - metalness) * albedo / 3.14159;
        float3 specular = calculateSpecular(F0, roughness, NdotH, NdotV, NdotL, VdotH);

        return (diffuse + specular) * NdotL;
    }

    float3 calculateSpecular(float3 F0, float roughness, float NdotH, float NdotV, float NdotL, float VdotH) {
        // Simplified specular calculation
        float alpha = roughness * roughness;
        float D = alpha * alpha / (3.14159 * pow(NdotH * NdotH * (alpha * alpha - 1.0) + 1.0, 2.0));
        float G = NdotV * NdotL;
        float3 F = F0 + (float3(1, 1, 1) - F0) * pow(1.0 - VdotH, 5.0);

        return D * G * F / max(0.0001, 4.0 * NdotV * NdotL);
    }
}

// Generic lighting calculation function
template<B : IBRDF>
float3 calculateLighting(B brdf, float3 albedo, float3 normal, float3 viewDir, float3 lightColor) {
    float3 lightDir = normalize(float3(1, 1, 1));
    return brdf.evaluate(albedo, normal, viewDir, lightDir) * lightColor;
}

// Shader entry points
[shader("vertex")]
export PSInput VSMain(VSInput input) {
    PSInput output;
    float4 worldPos = mul(scene.params.world, float4(input.position, 1.0));
    output.position = mul(scene.params.viewProj, worldPos);
    output.worldPos = worldPos.xyz;
    output.normal = normalize(mul((float3x3)scene.params.world, input.normal));
    output.texCoord = input.texCoord;
    return output;
}

[shader("pixel")]
export float4 PSMain(PSInput input) : SV_TARGET {
    float4 albedo = material.albedoMap.Sample(material.textureSampler, input.texCoord) * material.params.baseColor;
    float2 metallicRoughness = material.metallicRoughnessMap.Sample(material.textureSampler, input.texCoord).rg;
    float metalness = metallicRoughness.r * material.params.metallic;
    float roughnessValue = metallicRoughness.g * material.params.roughness;

    float3 normal = normalize(input.normal);
    float3 viewDir = normalize(scene.params.cameraPosition - input.worldPos);

    // Create BRDF with material parameters
    PBRBRDF brdf;
    brdf.metalness = metalness;
    brdf.roughness = roughnessValue;

    // Calculate lighting using the generic function
    float3 color = calculateLighting(brdf, albedo.rgb, normal, viewDir, float3(1, 1, 1));

    return float4(color, albedo.a);
}
----

The Slang version demonstrates several improvements:

- Organized code with module system
- Parameter blocks for resource organization
- Interface-based polymorphism for BRDFs
- Generic lighting calculation function
- Explicit shader stage annotations
- Better separation of concerns

These improvements make the code more maintainable, flexible, and reusable while preserving the core functionality of the original HLSL shader.

== Best Practices for Writing Shaders in Slang/HLSL for Vulkan

=== Code Organization

* *Separate shader stages*: Keep different shader stages (vertex, fragment, compute, etc.) in separate files
* *Use structures for inputs and outputs*: Define clear structures for shader inputs and outputs
* *Consistent naming conventions*: Adopt a consistent naming scheme for variables, functions, and types
* *Modular design*: Break complex shaders into reusable functions and components

Example of a well-organized HLSL shader:

[source,hlsl]
----
// Common structures and constants
struct VSInput {
    [[vk::location(0)]] float3 Position : POSITION0;
    [[vk::location(1)]] float3 Normal : NORMAL0;
    [[vk::location(2)]] float2 TexCoord : TEXCOORD0;
};

struct VSOutput {
    float4 Position : SV_POSITION;
    [[vk::location(0)]] float3 WorldPos : POSITION0;
    [[vk::location(1)]] float3 Normal : NORMAL0;
    [[vk::location(2)]] float2 TexCoord : TEXCOORD0;
};

// Uniform buffer with transformation matrices
struct SceneUBO {
    float4x4 model;
    float4x4 view;
    float4x4 projection;
};

[[vk::binding(0, 0)]]
ConstantBuffer<SceneUBO> ubo;

// Vertex shader main function
VSOutput main(VSInput input) {
    VSOutput output = (VSOutput)0;

    // Transform position to clip space
    float4 worldPos = mul(ubo.model, float4(input.Position, 1.0));
    output.Position = mul(ubo.projection, mul(ubo.view, worldPos));

    // Pass through other attributes
    output.WorldPos = worldPos.xyz;
    output.Normal = mul((float3x3)ubo.model, input.Normal);
    output.TexCoord = input.TexCoord;

    return output;
}
----

=== Performance Considerations

* *Minimize divergent control flow*: Avoid complex branching within shader wavefronts
* *Optimize memory access patterns*: Group related data together to improve cache coherency
* *Reduce register pressure*: Limit the number of variables in high-register-usage sections
* *Use appropriate precision*: Use lower precision types (`half`, `min16float`) when full precision isn't needed
* *Leverage subgroup operations*: Use subgroup/wave intrinsics for efficient parallel operations
* *Prefer compile-time constants*: Use specialization constants for values known at pipeline creation time

Example of using specialization constants:

[source,hlsl]
----
// Define specialization constants
[[vk::constant_id(0)]] const bool USE_NORMAL_MAPPING = true;
[[vk::constant_id(1)]] const int LIGHT_COUNT = 4;
[[vk::constant_id(2)]] const float SPECULAR_POWER = 32.0;

// Use in conditional code
float3 CalculateNormal(float3 normal, float3 tangent, float2 texCoord) {
    if (USE_NORMAL_MAPPING) {
        // Complex normal mapping calculation
        return CalculateNormalFromMap(normal, tangent, texCoord);
    } else {
        // Simple pass-through
        return normalize(normal);
    }
}
----

=== Debugging and Validation

* *Add debug markers*: Use comments or debug variables to mark important sections
* *Validate inputs*: Check for NaN or invalid values in critical calculations
* *Use validation layers*: Enable Vulkan validation layers during development
* *Leverage shader debugging tools*: Use tools like RenderDoc or NVIDIA Nsight for shader debugging
* *Implement fallbacks*: Provide simpler code paths for debugging complex algorithms

=== Vulkan-Specific Best Practices

* *Explicit bindings*: Always specify explicit descriptor set and binding indices
* *Consistent descriptor layouts*: Maintain consistent descriptor layouts across shader stages
* *Minimize descriptor set changes*: Group resources to minimize descriptor set changes during rendering
* *Consider push constants*: Use push constants for frequently changing small data
* *Be mindful of SPIR-V limitations*: Some HLSL features may not translate directly to SPIR-V

== Migration from GLSL to HLSL/Slang

=== Conceptual Differences

GLSL and HLSL have different programming paradigms:

* *GLSL*: More procedural, similar to C
* *HLSL*: More object-oriented, similar to C++

Key conceptual differences include:

* *Entry points*: GLSL uses `void main()`, HLSL uses typed functions with explicit inputs/outputs
* *Built-ins vs. semantics*: GLSL uses built-in variables, HLSL uses semantics
* *Resource binding*: Different syntax for binding resources
* *Matrix layout*: GLSL uses column-major by default, HLSL uses row-major by default

=== Syntax Translation Guide

==== Data Types

[options="header"]
|====
| GLSL | HLSL | Example
| vec_n_ | float_n_ | vec4 → float4
| ivec_n_ | int_n_ | ivec3 → int3
| uvec_n_ | uint_n_ | uvec2 → uint2
| mat_nxm_ | float_nxm_ | mat4 → float4x4
|====

==== Shader Inputs/Outputs

GLSL:
[source,glsl]
----
// Vertex shader inputs
layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inNormal;

// Vertex shader outputs
layout(location = 0) out vec3 outNormal;
layout(location = 1) out vec2 outUV;

void main() {
    gl_Position = ubo.projectionMatrix * ubo.viewMatrix * ubo.modelMatrix * vec4(inPosition, 1.0);
    outNormal = inNormal;
    outUV = inUV;
}
----

HLSL:
[source,hlsl]
----
// Input/output structures
struct VSInput {
    [[vk::location(0)]] float3 Position : POSITION0;
    [[vk::location(1)]] float3 Normal : NORMAL0;
};

struct VSOutput {
    float4 Position : SV_POSITION;
    [[vk::location(0)]] float3 Normal : NORMAL0;
    [[vk::location(1)]] float2 UV : TEXCOORD0;
};

// Main function with explicit input/output
VSOutput main(VSInput input) {
    VSOutput output = (VSOutput)0;
    output.Position = mul(ubo.projectionMatrix, mul(ubo.viewMatrix, mul(ubo.modelMatrix, float4(input.Position, 1.0))));
    output.Normal = input.Normal;
    output.UV = input.UV;
    return output;
}
----

==== Resource Binding

GLSL:
[source,glsl]
----
// Uniform buffer
layout(set = 0, binding = 0) uniform UBO {
    mat4 model;
    mat4 view;
    mat4 projection;
} ubo;

// Texture and sampler
layout(set = 0, binding = 1) uniform sampler2D texAlbedo;

// Storage buffer
layout(set = 0, binding = 2) buffer SSBO {
    vec4 data[];
} ssbo;
----

HLSL:
[source,hlsl]
----
// Uniform buffer
struct UBO {
    float4x4 model;
    float4x4 view;
    float4x4 projection;
};
[[vk::binding(0, 0)]]
ConstantBuffer<UBO> ubo;

// Texture and sampler
[[vk::binding(1, 0)]]
Texture2D texAlbedo;
[[vk::binding(1, 0)]]
SamplerState sampAlbedo;

// Storage buffer
struct SSBO {
    float4 data[];
};
[[vk::binding(2, 0)]]
RWStructuredBuffer<float4> ssbo;
----

==== Built-ins and Special Variables

[options="header"]
|====
| GLSL | HLSL | Description
| gl_Position | SV_Position | Vertex position output
| gl_FragCoord | SV_Position | Fragment position
| gl_VertexIndex | SV_VertexID | Vertex index
| gl_InstanceIndex | SV_InstanceID | Instance index
| gl_FragDepth | SV_Depth | Fragment depth output
| gl_FrontFacing | SV_IsFrontFace | Front-facing flag
| gl_PrimitiveID | SV_PrimitiveID | Primitive ID
|====

==== Common Functions

[options="header"]
|====
| GLSL | HLSL | Description
| mix(x, y, a) | lerp(x, y, a) | Linear interpolation
| fract(x) | frac(x) | Fractional part
| dFdx(p) | ddx(p) | Derivative in x direction
| dFdy(p) | ddy(p) | Derivative in y direction
| texture(sampler, coord) | sampler.Sample(texture, coord) | Texture sampling
|====

=== Common Migration Challenges

* *Matrix multiplication*: GLSL uses `*` operator, HLSL uses `mul()` function
* *Texture sampling*: Different syntax for texture access
* *Swizzling*: Both support swizzling but with subtle differences
* *Preprocessor directives*: Different preprocessor capabilities
* *Extension handling*: GLSL requires explicit extension enabling, HLSL doesn't

=== Migration Tools

* *DXC*: The DirectX Shader Compiler can help validate HLSL code
* *SPIRV-Cross*: Can convert between GLSL and HLSL via SPIR-V
* *Automated translation tools*: Various tools can assist with bulk translation
* *IDE plugins*: Some editors have plugins to help with shader language conversion

== Vulkan-Specific Semantics, Bindings, and Entry Points

=== Descriptor Binding in HLSL/Slang

HLSL offers two approaches for binding resources in Vulkan:

* *HLSL register syntax*:
[source,hlsl]
----
Texture2D albedoMap : register(t0, space1);
SamplerState samplerState : register(s0, space1);
----

* *Vulkan-specific attributes*:
[source,hlsl]
----
[[vk::binding(0, 1)]]
Texture2D albedoMap;
[[vk::binding(0, 1)]]
SamplerState samplerState;
----

You can also combine both approaches for cross-API compatibility:
[source,hlsl]
----
[[vk::binding(0, 1)]]
Texture2D albedoMap : register(t0, space1);
----

=== Resource Types and Register Spaces

[options="header"]
|====
| Resource Type | HLSL Type | Register Type | Vulkan Equivalent
| Uniform Buffer | ConstantBuffer<T> | b | VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
| Storage Buffer | RWStructuredBuffer<T> | u | VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
| Texture | Texture2D, Texture3D, etc. | t | VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
| Storage Image | RWTexture2D, etc. | u | VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
| Sampler | SamplerState | s | VK_DESCRIPTOR_TYPE_SAMPLER
| Combined Image Sampler | N/A (separate in HLSL) | N/A | VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
|====

=== Push Constants

Push constants provide a way to quickly update small amounts of shader data without descriptor sets:

[source,hlsl]
----
// Define push constant structure
struct PushConstants {
    float4x4 transform;
    float4 color;
    float time;
};

// Declare push constants block
[[vk::push_constant]]
PushConstants pushConstants;

// Use in shader
float4 TransformedPosition = mul(pushConstants.transform, float4(position, 1.0));
----

=== Specialization Constants

Specialization constants allow you to specialize shaders at pipeline creation time:

[source,hlsl]
----
// Define specialization constants with IDs and default values
[[vk::constant_id(0)]] const bool USE_LIGHTING = true;
[[vk::constant_id(1)]] const int LIGHT_COUNT = 4;
[[vk::constant_id(2)]] const float AMBIENT_INTENSITY = 0.1;

// Use in shader code
float3 CalculateLighting() {
    float3 result = float3(AMBIENT_INTENSITY, AMBIENT_INTENSITY, AMBIENT_INTENSITY);

    if (USE_LIGHTING) {
        for (int i = 0; i < LIGHT_COUNT; i++) {
            // Add light contribution
            result += CalculateLightContribution(i);
        }
    }

    return result;
}
----

=== Shader Entry Points

In HLSL for Vulkan, you can specify custom entry point names:

[source,hlsl]
----
// Vertex shader entry point
VSOutput vs_main(VSInput input) {
    // Vertex shader code
}

// Fragment shader entry point
float4 ps_main(VSOutput input) : SV_TARGET {
    // Fragment shader code
}
----

When compiling with DXC, specify the entry point:
[source,bash]
----
dxc -spirv -T vs_6_0 -E vs_main shader.hlsl -Fo shader.vert.spv
dxc -spirv -T ps_6_0 -E ps_main shader.hlsl -Fo shader.frag.spv
----

=== Vulkan-Specific Features

==== Subgroup Operations

HLSL provides wave intrinsics that map to Vulkan subgroup operations:

[source,hlsl]
----
// Check if this is the first lane in the subgroup
if (WaveIsFirstLane()) {
    // Do something only once per subgroup
}

// Compute sum across all lanes in the subgroup
float total = WaveActiveSum(value);

// Broadcast a value from a specific lane
float broadcastValue = WaveReadLaneAt(value, laneIndex);
----

==== Buffer Device Address

For Vulkan's buffer device address feature:

[source,hlsl]
----
// In application code, pass buffer address via push constants
struct PushConstants {
    uint64_t bufferAddress;
};

// In shader
[[vk::push_constant]]
PushConstants pushConstants;

// Load data from the buffer address
float4 data = vk::RawBufferLoad<float4>(pushConstants.bufferAddress);
----

==== Ray Tracing

For ray tracing shaders, use the `[shader("type")]` attribute:

[source,hlsl]
----
// Ray generation shader
[shader("raygeneration")]
void RayGen() {
    // Ray generation code
}

// Closest hit shader
[shader("closesthit")]
void ClosestHit(inout RayPayload payload, in BuiltInTriangleIntersectionAttributes attribs) {
    // Closest hit code
}
----

== Compiling to SPIR-V

=== Using DirectX Shader Compiler (DXC)

The DirectX Shader Compiler (DXC) is the recommended tool for compiling HLSL and Slang to SPIR-V for Vulkan.

==== Command-Line Compilation

Basic command-line usage:

[source,bash]
----
# Compile vertex shader
dxc -spirv -T vs_6_0 -E main shader.hlsl -Fo shader.vert.spv

# Compile fragment shader
dxc -spirv -T ps_6_0 -E main shader.hlsl -Fo shader.frag.spv

# Compile compute shader
dxc -spirv -T cs_6_0 -E main shader.hlsl -Fo shader.comp.spv
----

Important command-line options:

* `-spirv`: Generate SPIR-V code
* `-T <profile>`: Specify shader profile (e.g., vs_6_0, ps_6_0)
* `-E <name>`: Specify entry point name
* `-Fo <file>`: Specify output file
* `-fvk-use-dx-layout`: Use DirectX memory layout rules
* `-fspv-extension=<ext>`: Enable specific SPIR-V extension
* `-fspv-reflect`: Generate reflection information

==== Shader Profiles

[options="header"]
|====
| Vulkan Shader Stage | DXC Profile | Minimum Shader Model
| Vertex | vs | 6.0
| Fragment | ps | 6.0
| Compute | cs | 6.0
| Geometry | gs | 6.0
| Tessellation Control | hs | 6.0
| Tessellation Evaluation | ds | 6.0
| Task | as | 6.5
| Mesh | ms | 6.5
| Ray Generation | lib | 6.3
| Any Hit | lib | 6.3
| Closest Hit | lib | 6.3
| Miss | lib | 6.3
| Intersection | lib | 6.3
| Callable | lib | 6.3
|====

==== Runtime Compilation

For runtime compilation, use the DXC API:

[source,cpp]
----
#include "dxc/dxcapi.h"

// Initialize DXC
CComPtr<IDxcLibrary> library;
CComPtr<IDxcCompiler3> compiler;
CComPtr<IDxcUtils> utils;
DxcCreateInstance(CLSID_DxcLibrary, IID_PPV_ARGS(&library));
DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&compiler));
DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&utils));

// Load shader source
CComPtr<IDxcBlobEncoding> sourceBlob;
utils->LoadFile(L"shader.hlsl", nullptr, &sourceBlob);

// Compile arguments
std::vector<LPCWSTR> arguments = {
    L"-spirv",              // Generate SPIR-V
    L"-T", L"ps_6_0",       // Shader profile
    L"-E", L"main",         // Entry point
    // Additional options as needed
};

// Compile shader
DxcBuffer buffer = {};
buffer.Ptr = sourceBlob->GetBufferPointer();
buffer.Size = sourceBlob->GetBufferSize();
buffer.Encoding = DXC_CP_ACP;

CComPtr<IDxcResult> result;
compiler->Compile(&buffer, arguments.data(), arguments.size(), nullptr, IID_PPV_ARGS(&result));

// Check for errors
HRESULT status;
result->GetStatus(&status);
if (FAILED(status)) {
    CComPtr<IDxcBlobEncoding> errors;
    result->GetErrorBuffer(&errors);
    // Handle error
}

// Get compiled SPIR-V
CComPtr<IDxcBlob> spirvBlob;
result->GetResult(&spirvBlob);

// Create Vulkan shader module
VkShaderModuleCreateInfo createInfo = {};
createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
createInfo.codeSize = spirvBlob->GetBufferSize();
createInfo.pCode = reinterpret_cast<const uint32_t*>(spirvBlob->GetBufferPointer());

VkShaderModule shaderModule;
vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule);
----

=== Using Slang Compiler

For Slang shaders, use the Slang compiler with SPIR-V output:

[source,bash]
----
slangc -profile glsl_spirv -entry main -stage vertex shader.slang -o shader.vert.spv
----

=== Debugging and Validation

==== SPIR-V Tools

The SPIR-V Tools suite provides utilities for working with SPIR-V:

* *spirv-val*: Validates SPIR-V binaries
* *spirv-dis*: Disassembles SPIR-V to human-readable form
* *spirv-opt*: Optimizes SPIR-V binaries
* *spirv-cfg*: Generates control flow graphs

Example usage:
[source,bash]
----
# Validate SPIR-V binary
spirv-val shader.spv

# Disassemble SPIR-V for inspection
spirv-dis shader.spv -o shader.spvasm

# Optimize SPIR-V binary
spirv-opt -O shader.spv -o shader.opt.spv
----

==== Common Compilation Issues

* *Unsupported HLSL features*: Some HLSL features may not be supported in SPIR-V
* *Resource binding conflicts*: Ensure descriptor bindings don't conflict
* *Entry point mismatches*: Verify entry point names match between compilation and application
* *Shader model compatibility*: Ensure shader model is compatible with required features
* *Extension requirements*: Some features require specific SPIR-V extensions

== Advanced Topics

=== Cross-Compilation and Portability

For maximum portability between Vulkan and DirectX:

* Use conditional compilation with `#ifdef __spirv__`
* Maintain separate binding declarations for each API
* Use abstraction layers for API-specific features
* Consider shader generation tools for complex cases

Example of a cross-API shader:
[source,hlsl]
----
// Resource bindings for both APIs
#ifdef __spirv__
[[vk::binding(0, 0)]]
#endif
ConstantBuffer<Uniforms> uniforms : register(b0);

#ifdef __spirv__
[[vk::binding(1, 0)]]
#endif
Texture2D albedoTexture : register(t0);

// API-specific code paths
float4 SampleTexture(Texture2D tex, SamplerState samp, float2 uv) {
#ifdef __spirv__
    // Vulkan-specific sampling code if needed
    return tex.Sample(samp, uv);
#else
    // DirectX-specific sampling code if needed
    return tex.Sample(samp, uv);
#endif
}
----

=== Shader Interoperability

For interoperability between GLSL and HLSL/Slang in the same application:

* Maintain consistent descriptor set layouts
* Use explicit locations for all shader inputs/outputs
* Be mindful of matrix layout differences
* Consider using a shader generation system

=== Performance Optimization

Advanced optimization techniques:

* *Shader permutations*: Generate specialized shader variants for different feature combinations
* *Workgroup size tuning*: Optimize compute shader workgroup sizes for specific hardware
* *Memory layout optimization*: Align data structures to hardware requirements
* *Instruction scheduling*: Organize instructions to maximize parallelism
* *Register pressure management*: Minimize register usage in critical sections

=== Debugging Techniques

Advanced debugging approaches:

* *Debug prints*: Some implementations support debug printf in shaders
* *Debug buffers*: Write debug values to storage buffers for inspection
* *Shader instrumentation*: Add code to validate intermediate results
* *GPU debugging tools*: Use RenderDoc, NVIDIA Nsight, or AMD Radeon GPU Profiler

== Distribution Considerations

When deploying applications that use HLSL or Slang shaders with Vulkan, several distribution-related factors need to be considered to ensure optimal performance, compatibility, and user experience across different platforms and devices.

=== Precompilation vs. Runtime Compilation

Both approaches have advantages and trade-offs:

==== Precompilation

* *Advantages*:
** Faster application startup time
** No runtime dependency on shader compilers
** Validation errors caught during build rather than at runtime
** Opportunity for offline optimization

* *Disadvantages*:
** Increased package size when supporting multiple hardware targets
** Less flexibility for runtime adaptation
** Need to manage multiple precompiled variants

Example pipeline for precompilation:
[source,bash]
----
# Build script example
for shader in shaders/*.hlsl; do
  # Extract base name
  base=$(basename $shader .hlsl)

  # Determine shader type from filename suffix
  if [[ $base == *_vs ]]; then
    profile="vs_6_0"
    output="${base}.vert.spv"
  elif [[ $base == *_ps ]]; then
    profile="ps_6_0"
    output="${base}.frag.spv"
  elif [[ $base == *_cs ]]; then
    profile="cs_6_0"
    output="${base}.comp.spv"
  fi

  # Compile with optimization
  dxc -spirv -T $profile -E main $shader -O3 -Fo build/shaders/$output

  # Optionally validate
  spirv-val build/shaders/$output
done
----

==== Runtime Compilation

* *Advantages*:
** Ability to adapt to specific hardware capabilities at runtime
** Smaller distribution size (ship source instead of binaries)
** Easier to update and patch shaders
** Can generate specialized variants based on runtime conditions

* *Disadvantages*:
** Increased startup time or loading times
** Runtime dependency on shader compiler
** Potential for runtime shader compilation errors
** Additional memory usage during compilation

Example runtime compilation integration:
[source,cpp]
----
// Shader manager class that handles runtime compilation
class ShaderManager {
public:
    // Initialize DXC compiler once
    ShaderManager() {
        DxcCreateInstance(CLSID_DxcLibrary, IID_PPV_ARGS(&m_library));
        DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&m_compiler));
        DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&m_utils));
    }

    // Compile shader at runtime
    VkShaderModule CompileShader(const std::string& source,
                                 const std::string& entryPoint,
                                 const std::string& profile) {
        // Compilation logic here
        // ...

        // Return shader module
        return shaderModule;
    }

private:
    CComPtr<IDxcLibrary> m_library;
    CComPtr<IDxcCompiler> m_compiler;
    CComPtr<IDxcUtils> m_utils;
};
----

=== Hybrid Approaches

Many applications use a hybrid approach:

* Precompile common shaders for supported platforms
* Include fallback runtime compilation for edge cases
* Use shader caching to avoid recompilation

=== Binary Distribution Formats

When distributing precompiled SPIR-V shaders:

* *Raw SPIR-V binaries*: Direct output from DXC or Slang compiler
* *Compressed SPIR-V*: Apply compression to reduce distribution size
* *Custom container formats*: Package multiple shader variants with metadata
* *Embedded in application*: Include SPIR-V as binary arrays in application code

Example of embedding SPIR-V in C++ code:
[source,cpp]
----
// Generated header with embedded shader data
#include "compiled_shaders.h"

// Create shader module from embedded data
VkShaderModuleCreateInfo createInfo = {};
createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
createInfo.codeSize = sizeof(g_VertexShader);
createInfo.pCode = reinterpret_cast<const uint32_t*>(g_VertexShader);

VkShaderModule shaderModule;
vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule);
----

=== Shader Caching Strategies

Implementing an effective shader cache can significantly improve performance:

* *Disk-based caching*: Store compiled shaders on disk between application runs
* *Memory caching*: Keep frequently used shaders in memory
* *Pipeline caching*: Use Vulkan's `VkPipelineCache` to store compiled pipelines
* *Warm-up phase*: Precompile critical shaders during loading screens

Example of implementing a simple shader cache:
[source,cpp]
----
class ShaderCache {
public:
    // Try to load cached shader
    VkShaderModule GetCachedShader(const std::string& key) {
        auto it = m_cache.find(key);
        if (it != m_cache.end()) {
            return it->second;
        }
        return VK_NULL_HANDLE;
    }

    // Add shader to cache
    void CacheShader(const std::string& key, VkShaderModule module) {
        m_cache[key] = module;

        // Optionally persist to disk
        SaveToDisk(key, module);
    }

private:
    std::unordered_map<std::string, VkShaderModule> m_cache;

    // Implementation details for disk persistence
    void SaveToDisk(const std::string& key, VkShaderModule module);
    VkShaderModule LoadFromDisk(const std::string& key);
};
----

=== Version Management

Managing shader versions is crucial for maintenance and updates:

* *Versioning scheme*: Include version information in shader metadata
* *Compatibility checks*: Verify shader compatibility with application version
* *Incremental updates*: Support updating only changed shaders
* *Fallback mechanisms*: Provide fallback shaders for backward compatibility

Example versioning approach:
[source,cpp]
----
struct ShaderMetadata {
    uint32_t version;
    uint32_t minAppVersion;
    uint32_t featureFlags;
    char name[64];
};

// Shader package header
struct ShaderPackageHeader {
    uint32_t magic;           // Magic number for validation
    uint32_t version;         // Package version
    uint32_t shaderCount;     // Number of shaders in package
    uint32_t compatFlags;     // Compatibility flags
};
----

=== Platform-Specific Considerations

Different platforms may require special handling:

* *Desktop vs. mobile*: Optimize shader complexity based on target hardware
* *Vendor-specific optimizations*: Consider optimizations for specific GPU vendors
* *Feature detection*: Adapt to available hardware features
* *Memory constraints*: Be mindful of memory limitations, especially on mobile

Example of platform-specific shader selection:
[source,cpp]
----
VkShaderModule GetAppropriateShader(const DeviceCapabilities& caps) {
    if (caps.isLowPowerDevice) {
        return m_lowPowerShaderVariant;
    } else if (caps.vendorID == VENDOR_AMD) {
        return m_amdOptimizedVariant;
    } else if (caps.vendorID == VENDOR_NVIDIA) {
        return m_nvidiaOptimizedVariant;
    } else {
        return m_defaultShaderVariant;
    }
}
----

=== Size Optimization Techniques

Reducing shader size is important, especially for mobile applications:

* *SPIR-V optimization*: Use `spirv-opt` to optimize SPIR-V binaries
* *Strip debug information*: Remove debug information for release builds
* *On-demand loading*: Load shaders only when needed
* *Feature culling*: Remove unused features based on target platform
* *Compression*: Apply compression to shader binaries

Example optimization pipeline:
[source,bash]
----
# Optimize SPIR-V binary
spirv-opt -O --strip-debug shader.spv -o shader.opt.spv

# Check size reduction
echo "Original size: $(stat -c%s shader.spv) bytes"
echo "Optimized size: $(stat -c%s shader.opt.spv) bytes"

# Optionally compress
zstd -19 shader.opt.spv -o shader.opt.spv.zst
echo "Compressed size: $(stat -c%s shader.opt.spv.zst) bytes"
----

=== Distribution Security Considerations

It's important to understand the fundamental limitations of shader intellectual property protection:

* *Limited protection window*: Shader protection is effective only until the shader is loaded onto the GPU
* *Extraction vulnerability*: Once loaded, shaders can be extracted using GPU debuggers (like RenderDoc) or by recording Vulkan API calls
* *SPIR-V disassembly*: SPIR-V binaries can be disassembled to reveal shader logic
* *Inherent transparency*: The GPU execution model requires shaders to be in a readable format for the hardware

Common protection approaches and their limitations:

* *Obfuscation*: Can make shaders harder to understand but doesn't prevent extraction
* *Encryption*: Only protects shaders during distribution; they must be decrypted before GPU submission
* *Signature verification*: Helps ensure integrity but doesn't prevent reverse engineering
* *Anti-tampering measures*: Can detect modifications but not prevent shader analysis

Alternative protection strategies:

* *Legal protection*: Rely on licenses, patents, and legal agreements rather than technical measures
* *CPU-side algorithms*: Keep truly sensitive algorithms on the CPU where they're harder to extract
* *Split processing*: Divide algorithms between CPU and GPU to hide the complete picture
* *Regular updates*: Frequently update shaders to reduce the value of reverse engineering
* *Focus on unique data*: Often the data (textures, models, etc.) is more valuable than shader code

== Conclusion

HLSL and Slang provide powerful alternatives to GLSL for Vulkan shader development. By following the best practices and guidelines in this chapter, you can create efficient, maintainable, and portable shaders that leverage the strengths of these languages while taking full advantage of Vulkan's abilities.

The migration from GLSL to HLSL/Slang may require some effort, but the benefits in terms of code reuse, language features, and cross-API compatibility can be significant for many projects.

== References and Further Reading

* link:https://github.com/microsoft/DirectXShaderCompiler/blob/main/docs/SPIR-V.rst[HLSL to SPIR-V Feature Mapping Manual]
* link:https://github.com/shader-slang/slang[Slang Shader Language]
* link:https://github.com/KhronosGroup/SPIRV-Guide[SPIR-V Guide]
* link:https://www.khronos.org/blog/hlsl-first-class-vulkan-shading-language[HLSL as a First Class Vulkan Shading Language]
* link:https://docs.vulkan.org/spec/latest/chapters/interfaces.html[Vulkan Interfaces with SPIR-V]
* link:https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl[Microsoft HLSL Documentation]
